---
import type { HTMLAttributes } from 'astro/types';
import { findImage } from '~/utils/images';
import {
  getImagesOptimized,
  astroAssetsOptimizer,
  unpicOptimizer,
  isUnpicCompatible,
  type ImageProps,
} from '~/utils/images-optimization';

type Props = ImageProps;
type ImageType = {
  src: string;
  attributes: HTMLAttributes<'img'>;
};

const props = Astro.props;

if (props.alt === undefined || props.alt === null) {
  throw new Error();
}

if (typeof props.width === 'string') {
  props.width = parseInt(props.width);
}

if (typeof props.height === 'string') {
  props.height = parseInt(props.height);
}

if (!props.loading) {
  props.loading = 'lazy';
}

if (!props.decoding) {
  props.decoding = 'async';
}

const _image = await findImage(props.src);

let image: ImageType | undefined = undefined;
let avifImage: ImageType | undefined = undefined;
let webpImage: ImageType | undefined = undefined;

const isExternal = typeof _image === 'string' && (_image.startsWith('http://') || _image.startsWith('https://'));
const optimizer = isExternal && isUnpicCompatible(_image) ? unpicOptimizer : astroAssetsOptimizer;

if (_image) {
  // Generate AVIF version
  avifImage = await getImagesOptimized(_image, { ...props, format: 'avif' }, optimizer);
  // Generate WebP version
  webpImage = await getImagesOptimized(_image, { ...props, format: 'webp' }, optimizer);
  // Generate original/fallback version
  image = await getImagesOptimized(_image, props, optimizer);
}
---

{
  !image ? (
    <Fragment />
  ) : (
    <picture>
      {avifImage && <source type="image/avif" srcset={avifImage.attributes.srcset} sizes={avifImage.attributes.sizes} />}
      {webpImage && <source type="image/webp" srcset={webpImage.attributes.srcset} sizes={webpImage.attributes.sizes} />}
      <img src={image.src} crossorigin="anonymous" referrerpolicy="no-referrer" {...image.attributes} />
    </picture>
  )
}
